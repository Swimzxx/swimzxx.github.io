<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zxx,1462070722@qq.com"><title>学习jdk8-13新特性笔记 · 让天空解释着蔚蓝丶</title><meta name="description" content="#### jdk8的新特性

接口增强，default，static关键字在jdk1.8只前接口中只能使用抽象方法，而不能有任何方法的实现的jdk1.8里面则可以声明default和static修饰的方法

1234567891011121314151617181920212223242526/**"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">让天空解释着蔚蓝丶</a></h3><div class="description"><p>记录个人的学习</p></div></div></div><ul class="social-links"><li><a href="https://github.com/Swimzxx" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li><li><a href="1462070722@qq.com"><i class="fa fa-envelope"></i></a></li><li><a href="1462070722"><i class="fa fa-qq"></i></a></li></ul><div class="footer"><div class="p"> <span>QQ-Mail: 1462070722@qq.com</span></div><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">GitHub: https://github.com/Swimzxx.   	</a></div><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Powered by Hexo. </a><a>Theme by CaiCai & Ben & Core</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>学习jdk8-13新特性笔记</a></h3></div><div class="post-content"><p>﻿#### jdk8的新特性</p>
<ol>
<li><strong>接口增强，default，static关键字</strong><br>在jdk1.8只前接口中只能使用抽象方法，而不能有任何方法的实现的<br>jdk1.8里面则可以声明default和static修饰的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/11/16 11:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * 在jdk1.8以前接⼝⾥⾯是只能有抽象⽅法，不能有任何⽅法的实现的</span></span><br><span class="line"><span class="comment"> * 但是jdk1.8⾥⾯打破了这个规定，引⼊了新的关键字default，使⽤default修饰⽅法，可以在接⼝⾥⾯定义具体的⽅法实现</span></span><br><span class="line"><span class="comment"> * default修饰的方法称为默认⽅法，这个接⼝的实现类实现了这个接⼝之后，可以被重写，类似像抽象类的方法一样</span></span><br><span class="line"><span class="comment"> * static修饰的方法和普通的方法一样，可以被直接调用</span></span><br><span class="line"><span class="comment"> * jdk 9新增private方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接口里的默认方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接口里的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk9 新增private方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jdk9  新增私有方法"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>日期处理类</strong></li>
</ol>
<ul>
<li>SimpleDateFormate，Calendar旧版的缺点: java.util.Date 是非线程安全的api，涉及的比较差，日期时间的计算，比较都相对的麻烦</li>
<li>java 8新增日期处理类：LocalDate、LocalTime、Instant、Duration以及Period，这些类都包含在java.time包中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/11/16 11:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: LocalDate LocalTime LocalDateTime api类似</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        System.out.println(today);</span><br><span class="line">        <span class="comment">//获取年月日</span></span><br><span class="line">        System.out.println(today.getYear());</span><br><span class="line">        System.out.println(today.getMonth());</span><br><span class="line">        System.out.println(today.getDayOfMonth());</span><br><span class="line">        System.out.println(today.getDayOfWeek());</span><br><span class="line">        <span class="comment">//加减年份，加厚返回的对象才是修改后的，旧的依旧是旧的</span></span><br><span class="line">        LocalDate changeDate = today.plusYears(<span class="number">1</span>);</span><br><span class="line">        System.out.println(changeDate.getYear());</span><br><span class="line">        System.out.println(today.getYear());</span><br><span class="line">        <span class="comment">//日期比较</span></span><br><span class="line">        <span class="comment">//是否在之前</span></span><br><span class="line">        System.out.println(<span class="string">"isbefore:"</span>+today.isBefore(changeDate));</span><br><span class="line">        <span class="comment">//是否在之后</span></span><br><span class="line">        System.out.println(<span class="string">"isbefore:"</span>+today.isAfter(changeDate));</span><br><span class="line"></span><br><span class="line">   		<span class="comment">// jdk8引入 DateTimeFormatter是线程安全的SimpleDateFormat</span></span><br><span class="line">        LocalDateTime lt = LocalDateTime.now();</span><br><span class="line">        System.out.println(lt);<span class="comment">// 2019-11-07T23:12:29.056</span></span><br><span class="line">        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String ldtStr = dtf.format(lt);</span><br><span class="line">        System.out.println(ldtStr);<span class="comment">// 2019-11-07 23:12:29</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取指定时间对象</span></span><br><span class="line">        LocalDateTime ldt = LocalDateTime.of(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">30</span>);</span><br><span class="line">        System.out.println(changeDate);<span class="comment">// 2020-10-01T10:40:30</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Duration基于时间值,Period基于日期值，</span></span><br><span class="line">        <span class="comment">//Duration类表示秒或纳秒时间间隔</span></span><br><span class="line">        <span class="comment">//适合处理较短的时间，需要更高的精确性。使用between()方法比较两个瞬间的差：</span></span><br><span class="line">        Instant start = Instant.parse(<span class="string">"2019-11-16T11:15:30.00Z"</span>);</span><br><span class="line">        Instant end = Instant.parse(<span class="string">"2019-11-16T11:16:30.00Z"</span>);</span><br><span class="line">        Duration duration = Duration.between(start,end);<span class="comment">//第⼆个参数减第⼀个参数</span></span><br><span class="line">        System.out.println(duration.toDays());<span class="comment">//两个时间差的天数</span></span><br><span class="line">        System.out.println(duration.toHours());<span class="comment">//两个时间差的⼩时数</span></span><br><span class="line">        System.out.println(duration.toMinutes());<span class="comment">//两个时间差的分钟数</span></span><br><span class="line">        System.out.println(duration.toMillis());<span class="comment">//两个时间差的毫秒数</span></span><br><span class="line">        System.out.println(duration.toNanos());<span class="comment">//两个时间差的纳秒数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Period 类表示一段时间的年、月、日，使用between()方法获取两个日期之间的差</span></span><br><span class="line">        LocalDate startDate = LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">16</span>);</span><br><span class="line">        LocalDate endDate = LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        Period period = Period.between(startDate,endDate);</span><br><span class="line">        System.out.println(<span class="string">"per:"</span>+period.getYears());<span class="comment">//两个时间差的年数</span></span><br><span class="line">        System.out.println(<span class="string">"per:"</span>+period.getMonths());<span class="comment">//两个时间差的月</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p><strong>base64</strong><br>新增base64 编解码api</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line">    Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line"></span><br><span class="line">    String str = <span class="string">"这是一个测试"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    String encodText = encoder.encodeToString(bytes);</span><br><span class="line">    System.out.println(encodText);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(decoder.decode(encodText),<span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Optionnal类</strong></p>
<p><strong>Optional类的作用：</strong></p>
<ul>
<li>主要解决的问题是：空指针异常  NullPointerException</li>
<li>本质上是一个包含有可选值的包装类，Opertional类既可以为含有对象也可以为空</li>
</ul>
</li>
</ol>
<p><strong>1&gt; 创建opertional类</strong><br>    of()<br>     null传进去会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt = Optional.of(user);</span><br></pre></td></tr></table></figure>
<p>   ofNullable()<br>   对象可能是null也可能是非null 就应该使用ofNullable()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt = Optional.ofNullable(user);</span><br></pre></td></tr></table></figure>
<p> <strong>2&gt;访问Optional对象的值</strong><br>     get()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt = Optional.ofNullable(student); </span><br><span class="line">Student s = opt.get();</span><br></pre></td></tr></table></figure>
<p>如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象一般使用get之前需要先验证是否有值，不然会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Student student = <span class="keyword">null</span>;</span><br><span class="line"> test(student);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line"> Optional&lt;Student&gt; opt = Optional.ofNullable(student);</span><br><span class="line"> System.out.println(opt.isPresent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3&gt;兜底方法</strong><br>使用：当value值为null时，给予一个默认值:<br>方法1：orElse(T other)<br>方法2：orElseGet(Supplier&lt;? extends T&gt; other)<br>方法3：orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student= <span class="keyword">null</span>;</span><br><span class="line">    Student= Optional.ofNullable(student).orElse(createStudent());</span><br><span class="line">    Student= Optional.ofNullable(student).orElseGet(() -&gt; createStudent());</span><br><span class="line">	Student= Optional.ofNullable(student).orElseThrow(()-&gt;<span class="keyword">new</span> Exception(<span class="string">"学生不存在"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">createStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Studentstudent = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setName(<span class="string">"stu"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>orElse和orElseGet二者区别</strong>：<br>orElse()方法在Optional值为非空时，也会计算传入的参数，而orElseGet()方法只有在Optional值为空时才会执行传入的函数。<br>由于orElseGet()不是每次都会调用传入的方法，所以orElseGet()方法在性能上要优于orElse()方法。一般情况下，个人推荐使用orElseGet()方法更好</p>
<p><strong>4&gt;map()和faltMap()</strong><br><strong>map(Function&lt;? super T, ? extends U&gt; mapper)</strong><br>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">System.out.println(upperName.orElse(<span class="string">"name is null"</span>));</span><br></pre></td></tr></table></figure>
<p>这两个函数，在函数体上没什么区别。唯一区别的就是入参，map函数所接受的入参类型为Function&lt;? super T, ? extends U&gt;，而flapMap的入参类型为Function&lt;? super T, Optional<U>&gt;</U></p>
<p><strong>5&gt; filter(Predicate&lt;? super T&gt; predicate)</strong><br>使用：如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; student= Optional.ofNullable(student).filter(s -&gt; s.getName().length()&lt;<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p><strong>6&gt;Lambda表达式</strong></p>
<p>lambda表达式 使⽤场景(前提)：⼀个接⼝中只包含⼀个⽅法，则可以使⽤Lambda表达式，这样<br>的接⼝称之为“函数接⼝” 语法： (params) -&gt; expression</p>
<blockquote>
<p>第⼀部分为括号内⽤逗号分隔的形式参数，参数是函数式接⼝⾥⾯⽅法的参数；第⼆部分为⼀个箭<br>头符号：-&gt;；第三部分为⽅法体，可以是表达式和代码块<br>参数列表 ：<br> 括号中参数列表的数据类型可以省略不写<br> 括号中的参数只有⼀个，那么参数类型和()都可以省略不写<br>⽅法体：<br> 如果{}中的代码只有⼀⾏，⽆论有返回值，可以省略{}，return，分号，要⼀起省略，其他<br>则需要加上</p>
</blockquote>
<p> <strong>1&gt;Lambda 表达式的实现⽅式在本质是以匿名内部类的⽅式进⾏实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lambdatest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"jdk8以前创建线程"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//()对应run()没有一个参数，-&gt;后面是方法体内容</span></span><br><span class="line">        <span class="comment">//如果&#123;&#125;中的代码只有⼀行，⽆论有返回值，可以省略&#123;&#125;、return、分号，其他则需要加上</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">"lambda表达式创建线程"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"b"</span>,<span class="string">"e"</span>);</span><br><span class="line">        <span class="comment">// jdk8以前排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// lambda表达式排序</span></span><br><span class="line">        <span class="comment">//，前面的对应接口前面的参数，a b 对应compare里面的参数</span></span><br><span class="line">        Collections.sort(list,(a,b)-&gt;b.compareTo(a));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2&gt;自定义lambda接口流程</strong><br>定义⼀个函数式接⼝ 需要标注此接⼝ @FunctionalInterface，接口里面必须有且只能有一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperFunction</span>&lt;<span class="title">R</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> <span class="comment">// R表示返回值，T表示参数类型，t1 t2是具体参数</span></span><br><span class="line"> <span class="function">R <span class="title">operator</span><span class="params">(T t1, T t2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cacl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤：1定义一个函数方法 2 需要传入a和b两个参数 3传入的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">operator</span><span class="params">(Integer a,Integer b,Test1&lt;Integer,Integer&gt; of)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> of.operator(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	System.out.println(cacl.operator(<span class="number">1</span>,<span class="number">3</span>,(a,b)-&gt; a+b));</span><br><span class="line">       System.out.println(cacl.operator(<span class="number">1</span>,<span class="number">3</span>,(a,b)-&gt; a-b));</span><br><span class="line">       System.out.println(cacl.operator(<span class="number">1</span>,<span class="number">3</span>,(a,b)-&gt; a*b));</span><br><span class="line">       System.out.println(cacl.operator(<span class="number">1</span>,<span class="number">3</span>,(a,b)-&gt; a/b));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3&gt;⽅法引⽤与构造函数引⽤</strong><br>jdk1.8提供了另外⼀种调⽤⽅式 ::</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">说明:</span><br><span class="line">⽅法引⽤是⼀种更简洁易懂的lambda表达式，操作符是双冒号::，⽤来直接访问类或者实例已经存在的⽅法或构造⽅法</span><br><span class="line">通过⽅法引⽤，可以将⽅法的引⽤赋值给⼀个变量</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">	左边是容器（可以是类名，实例名），中间是" :: "，右边是相应的⽅法名</span><br><span class="line">	静态⽅法，则是ClassName::methodName。如 Object ::equals</span><br><span class="line">实例⽅法，则是Instance::methodName</span><br><span class="line">构造函数，则是 类名::new;</span><br><span class="line"></span><br><span class="line">单个参数</span><br><span class="line">	Function&lt;⼊参1, 返回类型&gt; func = ⽅法引⽤</span><br><span class="line">	应⽤ func.apply(⼊参);</span><br><span class="line"></span><br><span class="line">两个参数</span><br><span class="line">	BiFunction&lt;⼊参1,⼊参2, 返回类型&gt; func = ⽅法引⽤</span><br><span class="line">	应⽤ func.apply(⼊参1,⼊参2);</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>函数式编程</li>
</ol>
<p>内置的四⼤核⼼函数式接⼝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;T, R&gt; : 函数型接⼝：有⼊参，有返回值</span><br><span class="line"> <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"> </span><br><span class="line">Consumer&lt;T&gt; : 消费型接⼝：有⼊参，⽆返回值</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"> </span><br><span class="line">Supplier&lt;T&gt; : 供给型接⼝：⽆⼊参，有返回值</span><br><span class="line"> <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">Predicate&lt;T&gt; : 断⾔型接⼝：有⼊参，有返回值，返回值类型确定是<span class="keyword">boolean</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>1&gt; Function&lt;T, R&gt;</strong> </p>
<ul>
<li>传⼊⼀个值经过函数的计算返回另⼀个值</li>
<li>T：⼊参类型，R：出参类型<br>调⽤⽅法：R apply(T t)</li>
<li>作⽤：将转换逻辑提取出来，解耦合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function源码</span></span><br><span class="line">	<span class="meta">@FunctionalInterface</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">	 <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//BiFunction源码</span></span><br><span class="line">	<span class="meta">@FunctionalInterface</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">	 <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">//一个参数一个返回值</span></span><br><span class="line">        Function&lt;Integer,Integer&gt; func = a-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(func.apply(<span class="number">1</span>));</span><br><span class="line">		<span class="comment">//两个参数 一个返回值</span></span><br><span class="line">		BiFunction&lt;Integer, Integer,Boolean&gt; func1 = (a,b)-&gt;&#123;</span><br><span class="line">           <span class="keyword">return</span> a+b;</span><br><span class="line">       	&#125;;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2&gt; Consumer&lt; T &gt;</strong>   </p>
<ul>
<li>Consumer 消费型接⼝：有⼊参，⽆返回值</li>
<li>将 T 作为输⼊，不返回任何内容<br>调⽤⽅法：void accept(T t);<ul>
<li>没有出参，一般用于打印(foreach() )，发送短信等消费动作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//foreach遍历操作</span></span><br><span class="line">      List&lt;String&gt; list = Arrays.asList(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>);</span><br><span class="line">   list.forEach(obj-&gt;&#123;</span><br><span class="line">   System.out.println(obj);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   Consumer&lt;String&gt; consumer = obj-&gt;&#123;</span><br><span class="line">	 System.out.println(obj);</span><br><span class="line">	 System.out.println(<span class="string">"调用consumer接口"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">  sendMsg(<span class="string">"8888888"</span>,consumer);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String phone,Consumer&lt;String&gt; consumer)</span></span>&#123;</span><br><span class="line"> consumer.accept(phone);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3&gt; Supplier<T> : 供给型接⼝：⽆⼊参，有返回值</T></strong> </p>
<ul>
<li>Supplier: 供给型接⼝：⽆⼊参，有返回值</li>
<li>T：出参类型；没有⼊参</li>
<li>调⽤⽅法：T get()</li>
<li>泛型⼀定和⽅法的返回值类型是⼀种类型，如果需要获得⼀个数据,并且不需要传⼊参数,可<br>以使⽤Supplier接⼝，例如 ⽆参的⼯⼚⽅法，即⼯⼚设计模式创建对象，简单来说就是 提供者<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 	Student student = newStudent();</span><br><span class="line"> 	System.out.println(student.getName());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">newStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	Supplier&lt;Student&gt; supplier = ()-&gt; &#123;</span><br><span class="line"> 	Student student = <span class="keyword">new</span> Student();</span><br><span class="line"> 	student.setName(<span class="string">"默认名称"</span>);</span><br><span class="line"> 	<span class="keyword">return</span> student;</span><br><span class="line"> &#125;;</span><br><span class="line"> 	<span class="keyword">return</span> supplier.get();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> String name;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>4&gt; Predicate<T> : 断⾔型接⼝：有⼊参，有返回值，返回值类型确定是boolean</T></strong> </p>
<ul>
<li>Predicate: 断⾔型接⼝：有⼊参，有返回值，返回值类型确定是boolean</li>
<li>T：⼊参类型；出参类型是Boolean</li>
<li>调⽤⽅法：boolean test(T t);</li>
<li>⽤途： 接收⼀个参数，⽤于判断是否满⾜⼀定的条件，过滤数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	 List&lt;String&gt; list =Arrays.asList(<span class="string">"awewrwe"</span>,<span class="string">"vdssdsd"</span>,<span class="string">"aoooo"</span>,<span class="string">"psdddsd"</span>);</span><br><span class="line">	 List&lt;String&gt; results = filter(list,obj-&gt;obj.startsWith(<span class="string">"a"</span>));</span><br><span class="line">	 System.out.println(results);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; list,Predicate&lt;String&gt; predicate)</span> </span>&#123;</span><br><span class="line">	 List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	 <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">	 	<span class="keyword">if</span> (predicate.test(str)) &#123;</span><br><span class="line">	 		results.add(str);</span><br><span class="line">	 	&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">return</span> results;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>stream</li>
</ol>
<ul>
<li><p>通过将集合转为一种stream流的元素队列，通过声明性⽅式，<br>能够对集合中的每个元素进⾏⼀系列并⾏或串⾏的流⽔线操作</p>
</li>
<li><p>元素是特定类型的对象，所以元素集合看作⼀种流， 流在管道中传输， 且可以在管道的节点上进⾏处理， ⽐如 排序，聚合，过滤等操作</p>
</li>
<li><p>stream的操作可以分为两类，中间操作和结束操作</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">​&lt;div id&#x3D;&quot;flowchart-0&quot; class&#x3D;&quot;flow-chart&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">数据操作：</span><br><span class="line">- 数据元素便是原始集合，如List、Set、Map等</span><br><span class="line">- ⽣成流，可以是串⾏流stream() 或者并⾏流 parallelStream()</span><br><span class="line">- 中间操作，可以是 排序，聚合，过滤，转换等</span><br><span class="line">- 终端操作，很多流操作本身就会返回⼀个流，所以多个操作可以直接连接起来，最后统⼀进</span><br><span class="line">⾏收集</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">	List&lt;User&gt; list &#x3D; Arrays.asList(</span><br><span class="line">                &#x2F;&#x2F; name，age</span><br><span class="line">                new User(&quot;张三&quot;, 11),</span><br><span class="line">                new User(&quot;王五&quot;, 20),</span><br><span class="line">                new User(&quot;王五&quot;, 91),</span><br><span class="line">                new User(&quot;张三&quot;, 8),</span><br><span class="line">                new User(&quot;李四&quot;, 44),</span><br><span class="line">                new User(&quot;李四&quot;, 44),</span><br><span class="line">                new User(&quot;李四&quot;, 44)</span><br><span class="line">        );</span><br><span class="line">    &#x2F;&#x2F;foreach 迭代</span><br><span class="line">    list.forEach(user -&gt; System.out.println(user));</span><br><span class="line">    System.out.println(&quot;stream:&quot;);</span><br><span class="line">    list.stream().forEach(user -&gt; System.out.println(user));</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;将流中的每⼀个元素 T 映射为 R（类似类型转换</span><br><span class="line">    List&lt;String&gt; mapUser&#x3D; list.stream().map(obj-&gt;&quot;用户：&quot;+obj).collect(Collectors.toList());</span><br><span class="line">    list.forEach(obj-&gt;System.out.println(obj));</span><br><span class="line">    mapUser.forEach(obj-&gt;System.out.println(obj));</span><br><span class="line">        </span><br><span class="line">      &#x2F;&#x2F;filter  使用该方法过滤 (Predicate)</span><br><span class="line">	list.stream().filter(user -&gt; user.getAge()&gt;50).forEach(user -&gt; System.out.println(user));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;limit() 使用该方法截断</span><br><span class="line">    list.stream().limit(3).forEach(user -&gt; System.out.println(user));</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;skip() 与limit互斥，使用该方法跳过元素</span><br><span class="line">    list.stream().skip(3).forEach(user-&gt; System.out.println(user));</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;sort 排序</span><br><span class="line">    List&lt;User&gt; users &#x3D; list.stream().sorted(Comparator.comparing(User::getAge).reversed()).collect(Collectors.toList());</span><br><span class="line">    System.out.println(users);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;allmatch函数 检查是否匹配所有元素，只有全部符合才返回true</span><br><span class="line">   List&lt;String&gt; list &#x3D; Arrays.asList(&quot;springboot&quot;, &quot;springcloud&quot;,&quot;redis&quot;,&quot;git&quot;, &quot;netty&quot;, &quot;java&quot;, &quot;html&quot;, &quot;docker&quot;);</span><br><span class="line">   boolean flag &#x3D; list.stream().allMatch(obj-&gt;obj.length()&gt;1);</span><br><span class="line">   System.out.println(flag);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;anyMatch函数 检查是否⾄少匹配⼀个元素</span><br><span class="line">	List&lt;String&gt; list &#x3D; Arrays.asList(&quot;springboot&quot;, &quot;springcloud&quot;,&quot;redis&quot;,&quot;git&quot;, &quot;netty&quot;, &quot;java&quot;, &quot;html&quot;, &quot;docker&quot;);</span><br><span class="line">    boolean flag &#x3D; list.stream().anyMatch(obj-&gt;obj.length()&gt;18);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;Max Min</span><br><span class="line">    Optional&lt;User&gt; opu &#x3D; list.stream().max(Comparator.comparing(User::getAge));</span><br><span class="line">    System.out.println(opu.get().getAge());</span><br><span class="line"></span><br><span class="line">    Optional&lt;User&gt; opu &#x3D; list.stream().max((s1,s2)-&gt;Integer.compare(s1.getAge(),s2.getAge()));</span><br><span class="line">    System.out.println(opu.get().getAge());</span><br><span class="line">    Optional&lt;User&gt; minopu &#x3D; list.stream().min((s1,s2)-&gt;Integer.compare(s1.getAge(),s2.getAge()));</span><br><span class="line">    System.out.println(minopu .get().getAge());</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;并⾏流parallelStream</span><br><span class="line">	&#x2F;&#x2F;顺序输出</span><br><span class="line">	List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">	numbers.stream().forEach(System.out::println);</span><br><span class="line">	&#x2F;&#x2F;并⾏乱序输出</span><br><span class="line">	List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">	numbers.parallelStream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;reduce 聚合操作</span><br><span class="line">	&#x2F;&#x2F;reduce 聚合操作</span><br><span class="line">    Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br><span class="line"></span><br><span class="line">    int result &#x3D; Stream.of(1,2,3,4,5).reduce(new</span><br><span class="line">     BinaryOperator&lt;Integer&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public Integer apply(Integer item1, Integer item2) &#123;</span><br><span class="line">             return item1 + item2;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).get();</span><br><span class="line">    System.out.println(&quot;result:&quot;+result);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;聚合统计collector</span><br><span class="line">    list.stream().collect(Collectors.toList());</span><br><span class="line">    System.out.println(list);</span><br><span class="line">	&#x2F;&#x2F;Collectors.toMap()</span><br><span class="line">	&#x2F;&#x2F;Collectors.toSet()</span><br><span class="line">	&#x2F;&#x2F;Collectors.toCollection() ：⽤⾃定义的实现Collection的数据结构收集</span><br><span class="line">	&#x2F;&#x2F;Collectors.toCollection(LinkedList::new)</span><br><span class="line">	&#x2F;&#x2F;Collectors.toCollection(CopyOnWriteArrayList::new)</span><br><span class="line">	&#x2F;&#x2F;Collectors.toCollection(TreeSet::new)</span><br><span class="line">	 &#x2F;&#x2F;joining收集器</span><br><span class="line">    String str &#x3D; Stream.of(&quot;springboot&quot;,&quot;springcloud&quot;,&quot;dubbo&quot;).collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">    System.out.println(str);	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;partitioningBy分组 </span><br><span class="line">    List&lt;String&gt; strlist &#x3D; Arrays.asList(&quot;java&quot;, &quot;springboot&quot;, &quot;HTML5&quot;,&quot;nodejs&quot;,&quot;CSS3&quot;);</span><br><span class="line">    Map&lt;Boolean, List&lt;String&gt;&gt; result &#x3D; strlist.stream().collect(partitioningBy(s -&gt; s.length()&gt;4));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">     &#x2F;&#x2F;groupingBy()分组</span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; slist &#x3D; strlist.stream().collect(Collectors.groupingBy(o -&gt; o.length()));</span><br><span class="line">    System.out.println(slist);</span><br><span class="line">    &#x2F;&#x2F;summarizingint 集合统计</span><br><span class="line">    IntSummaryStatistics summaryStatistics &#x3D; strlist.stream().collect(Collectors.summarizingInt(String :: length));</span><br><span class="line">    System.out.println(summaryStatistics.getMax());</span><br><span class="line">    System.out.println(summaryStatistics.getAverage());</span><br><span class="line">    System.out.println(summaryStatistics.getCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdk9新特性"><a href="#jdk9新特性" class="headerlink" title="jdk9新特性"></a>jdk9新特性</h3><ol>
<li>jdk9新增的接⼝私有⽅法</li>
<li>增强try-with-resource</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk7</span></span><br><span class="line">OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line"><span class="keyword">try</span>(OutputStream temp = out;) &#123;</span><br><span class="line"> 	temp.write((filepath+<span class="string">"学习jdk新特性"</span>).getBytes());</span><br><span class="line"> &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"> 	e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//jdk9</span></span><br><span class="line">OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line"> <span class="keyword">try</span> (out) &#123;</span><br><span class="line">	 out.write((filepath + <span class="string">"学习jdk新特性"</span>).getBytes());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> 	e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>增强stream，增加部分方法</li>
</ol>
<ul>
<li>takeWhile<br>  有序的集合：从 Stream 中获取⼀部分数据, 返回从头开始的尽可能多的元素, 直到遇到第⼀个false结果，如果第⼀个值不满⾜断⾔条件，将返回⼀个空的 Stream<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	List&lt;String&gt; list = List.of(<span class="string">"springboot"</span>,<span class="string">"java"</span>,<span class="string">"html"</span>,<span class="string">""</span>,<span class="string">"git"</span>).stream().takeWhile(obj-&gt;!obj.isEmpty()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//⽆序集合，返回元素不固定，暂⽆⽆实际使⽤场景</span></span><br><span class="line">	Set&lt;String&gt; set =Set.of(<span class="string">"springboot"</span>,<span class="string">"java"</span>,<span class="string">"html"</span>,<span class="string">""</span>,<span class="string">"git"</span>).stream().takeWhile(obj-&gt;!obj.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li>
<li>dropWhile  与 takeWhile相反，返回剩余的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =List.of(<span class="string">"springboot"</span>,<span class="string">"java"</span>,<span class="string">"html"</span>,<span class="string">""</span>,<span class="string">"git"</span>).stream().dropWhile(obj-&gt;!obj.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建只读集合</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"spring"</span>, <span class="string">"springboot"</span>, <span class="string">"springmvc"</span>);</span><br><span class="line">list2.remove(<span class="number">0</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h3 id="jdk10新特性"><a href="#jdk10新特性" class="headerlink" title="jdk10新特性"></a>jdk10新特性</h3><ol>
<li>var作为局部变量类型推断标识符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// var作为局部变量类型推断标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> strVar = <span class="string">"springboot"</span>;</span><br><span class="line">        System.out.println(strVar <span class="keyword">instanceof</span> String);</span><br><span class="line">        <span class="comment">//根据10L 推断long 类型</span></span><br><span class="line">        <span class="keyword">var</span> longVar = Long.valueOf(<span class="number">10l</span>);</span><br><span class="line">        System.out.println(longVar <span class="keyword">instanceof</span> Long);</span><br><span class="line">        <span class="comment">//根据 true推断 boolean 类型</span></span><br><span class="line">        <span class="keyword">var</span> flag = Boolean.valueOf(<span class="string">"true"</span>);</span><br><span class="line">        System.out.println(flag <span class="keyword">instanceof</span> Boolean);</span><br><span class="line">        <span class="comment">// 推断 ArrayList&lt;String&gt;</span></span><br><span class="line">        <span class="keyword">var</span> listVar = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        System.out.println(listVar <span class="keyword">instanceof</span> ArrayList);</span><br><span class="line">        <span class="comment">// 推断 Stream&lt;String&gt;</span></span><br><span class="line">        <span class="keyword">var</span> streamVar = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>);</span><br><span class="line">        System.out.println(streamVar <span class="keyword">instanceof</span> Stream);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"这个是 flag 变量，值为true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (<span class="keyword">var</span> input = <span class="keyword">new</span> FileInputStream(<span class="string">"validation.txt"</span>)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdk11新特性"><a href="#jdk11新特性" class="headerlink" title="jdk11新特性"></a>jdk11新特性</h3><ol>
<li>httpclinet</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> URI uri = URI.create(<span class="string">"https://www.csdn.net/"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       testHttp2();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * get请求</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建连接两种方式：    var httpClient = HttpClient.newHttpClient();</span></span><br><span class="line">       <span class="keyword">var</span> httpClient = HttpClient.newBuilder().connectTimeout(Duration.ofMillis(<span class="number">5000</span>)).build();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 封装请求参数(默认get请求)</span></span><br><span class="line">       HttpRequest request = HttpRequest.newBuilder().timeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">                               .header(<span class="string">"key1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">                               .uri(uri).build();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">var</span> response = httpClient.send(request,</span><br><span class="line">           HttpResponse.BodyHandlers.ofString());</span><br><span class="line">           System.out.println(response.body());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * post请求</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       HttpClient httpClient = HttpClient.newHttpClient();</span><br><span class="line">       HttpRequest request = HttpRequest.newBuilder().uri(uri)</span><br><span class="line">                   .POST(HttpRequest.BodyPublishers.ofString(<span class="string">"phone=13113777337&amp;pwd=1234567890"</span>))</span><br><span class="line">                   <span class="comment">// from表单要用下面格式发送</span></span><br><span class="line">                   <span class="comment">//.header("Content-Type", "application/json")</span></span><br><span class="line">                   <span class="comment">//.POST(HttpRequest.BodyPublishers.ofString("&#123;\"phone\":\"13113777337\",\"pwd\":\"1234567890\"&#125;"))</span></span><br><span class="line">                   .build();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">var</span> response = httpClient.send(request,</span><br><span class="line">           HttpResponse.BodyHandlers.ofString());</span><br><span class="line">           System.out.println(response.body());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 异步GET请求</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAsynGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> httpClient = HttpClient.newBuilder().build();</span><br><span class="line">       <span class="keyword">var</span> request =</span><br><span class="line">       HttpRequest.newBuilder().timeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">       .header(<span class="string">"key1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">       .uri(uri).build();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 异步请求通过CompletableFuture实现</span></span><br><span class="line">           CompletableFuture&lt;String&gt; result = httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">                        .thenApply(HttpResponse::body);</span><br><span class="line">           System.out.println(result.get());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发送http2请求</span></span><br><span class="line"><span class="comment">    *     HTTP2协议的强制要求https，如果目标URI是HTTP的，则无法使用HTTP 2协议</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHttp2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> httpClient = HttpClient.newBuilder().connectTimeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">                                   .version(HttpClient.Version.HTTP_2)</span><br><span class="line">                                   .build();</span><br><span class="line">       <span class="keyword">var</span> request = HttpRequest.newBuilder().timeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">       .header(<span class="string">"key1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">       .uri(uri)</span><br><span class="line">       .build();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">var</span> response = httpClient.send(request,</span><br><span class="line">           HttpResponse.BodyHandlers.ofString());</span><br><span class="line">           System.out.println(response.body());</span><br><span class="line">           System.out.println(response.version());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdk13"><a href="#jdk13" class="headerlink" title="jdk13"></a>jdk13</h3><ol>
<li>switch增强</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(i)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span> -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">          System.out.println(<span class="string">"这是多⾏行行语句句"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>,<span class="number">11</span>,<span class="number">111</span> -&gt; System.out.println(<span class="string">"one"</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">"two"</span>);</span><br><span class="line">      <span class="keyword">default</span> -&gt; System.out.println(<span class="string">"default"</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多行文本块 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String html = <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                       <span class="string">"&lt;body&gt;\n"</span> +</span><br><span class="line">                           <span class="string">"&lt;p&gt;Hello, world&lt;/p&gt;\n"</span> +</span><br><span class="line">                       <span class="string">"&lt;/body&gt;\n"</span> +</span><br><span class="line">                    <span class="string">"&lt;/html&gt;\n"</span>;</span><br><span class="line">      String query = <span class="string">"SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\n"</span> +</span><br><span class="line">                     <span class="string">"WHERE `CITY` = 'INDIANAPOLIS'\n"</span> +</span><br><span class="line">                     <span class="string">"ORDER BY `EMP_ID`, `LAST_NAME`;\n"</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 新：不用对转义字符进行转义</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      String html2 = <span class="string">""</span><span class="string">""</span></span><br><span class="line">                      &lt;html&gt;</span><br><span class="line">                          &lt;body&gt;</span><br><span class="line">                              &lt;p&gt;Hello, world&lt;/p&gt;    </span><br><span class="line">                          &lt;/body&gt;</span><br><span class="line">                      &lt;/html&gt;</span><br><span class="line">                     <span class="string">""</span><span class="string">";</span></span><br><span class="line"><span class="string">      String query = "</span><span class="string">""</span></span><br><span class="line">                      SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`</span><br><span class="line">                      WHERE `CITY` = <span class="string">'INDIANAPOLIS'</span></span><br><span class="line">                      ORDER BY `EMP_ID`, `LAST_NAME`;</span><br><span class="line">                     <span class="string">""</span><span class="string">";</span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure>

<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op[数据集合] --> sop[生成流]
    sop[生成流] --> cop[中间操作 ]
     cop[中间操作] --> endop[终端操作]
​```</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-03-16</span><i class="fa fa-tag"></i><a class="tag" href="/categories/tool/" title="tool">tool </a><a class="tag" href="/tags/jdk/" title="jdk">jdk </a><a class="tag" href="/tags/lambda/" title="lambda">lambda </a><a class="tag" href="/tags/stream操作/" title="stream操作">stream操作 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2020/03/16/学习jdk8-13新特性笔记/,让天空解释着蔚蓝丶,学习jdk8-13新特性笔记,;" target="_blank" rel="noopener"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/03/16/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="RocketMQ学习笔记">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/03/15/hexo%E6%90%AD%E5%BB%BA%E5%88%B0GitHub/" title="hexo搭建到GitHub">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'ly0CV4kyiRednsvsP068Sdm8-gzGzoHsz',
  app_key:'8je5T9Gu5BL66JMvYcm9pVpn',
  placeholder:'ヾﾉ≧∀≦)o来啊，快活啊!',
  path: window.location.pathname,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"width":200,"height":350,"position":"right"},"mobile":{"show":true,"scale":0.3},"log":false,"tagMode":false});</script></body></html>